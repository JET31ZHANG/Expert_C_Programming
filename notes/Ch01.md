# C: 穿越时空的迷雾
## C 语言的史前阶段
## C 语言的早期体验

根据编译器设计者的思路发展形成的语言特性：
- 数组下标从 0 而不是 1 开始。（定义一个数组 `a[100]` ，其合法范围是 `a[0]` 到 `a[99]`）
- C 语言的基本数据类型直接与底层硬件相对应。
- auto 关键字是摆设：auto 只对创建符号表入口的编译器设计者有意义。其意思是“在进入程序块时自动进行内存分配（与全局静态分配、堆上动态分配相反）”，是缺省的变量内存分配模式。
- 表达式中的数组名可以看作是指针。
- float 被自动扩展为 double：尽管在 ANSI C 中情况不再如此，但最初浮点数常量的精度都是 double 类型的。
- 不允许嵌套函数（函数内部包含另一个函数的定义）：简化了编译器，并稍微提高了 C 程序的运行时组织结构。
- register 关键字：程序中哪些变量经常被使用，这样就可以把他们存放到寄存器中。使用 register 关键字，简化了编译器，麻烦了程序员。

## 标准 I/O 库和 C 预处理器

在 C 语言中，绝大多数库函数或辅助程序都需要显式调用。
C 语言原先并没有定义 I/O，而是由库函数提供，后经优化和裁剪，成为标准 I/O 函数库。
C 预处理器的3个主要功能：
- 字符串替换：通常用于为常量提供一个符号名；
- 头文件包含（在BCPL首创）：一般性的声明可被分离到头文件中，并且可以被许多源文件使用。虽然约定采用 “.h” 作为头文件的扩展名，但在头文件和包含实现代码的对象库之间在命名上没有相应的约定。
- 通用代码模板的扩展：宏（macro）在连续几个调用中所接收的参数类型可以不同（宏的实际参数只是按原样输出）。在宏的扩展中，空格对扩展的结果影响很大。
```c
/* 它们表示的意思完全不同 */

#define a(y) a_expanded(y)
a(x);
// 被扩展为：
a_expanded(x);


#define a (y) a_expanded (y)
a(x);
// 被扩展为：
(y) a_expanded (y)(x);
```
**宏只应该适量使用。宏最好只用于命名常量，并为一些适当的结构提供简洁的记法。宏名应该大写。**

## K&R C

一个非比寻常的Bug
C 语言从Algol-68 继承了复合赋值符，允许对一个重复出现的操作数只写一次，提示代码生成器，操作数寻址也可以这样紧凑。（如，b += 3 等价于 b = b + 3）作为修改的一不慎，代码格式器程序缩进也作了相应修改，用于确定复合赋值符的过时形式、并交换二者的位置，把它转换为对应的标准形式。引入的bug是：任何东西（只要不是变量）如果她出现在赋值符后面，就会与赋值符交换位置。
```c
// 如果运气好，这个 Bug 会引起语法错误
epsilon=.0001;
// 会被叫换成：
epsilon.= 0001;

// 以下语句能够通过编译，但其作用与原语句不同
valve=!open;  /* valve 被设置为 open 的逻辑反 */
// 会被交换成：
valve!=open;  /* valve 与 open 进行不相等比较 */

/* 在赋值后面加个空格是很自然的事 */
```

## 今日之 ANSI C

ANSI 所采纳的C 语言标准是 ISO C。（ISO/IEC 9899:1994）

## 它很棒，但它符合标准吗？

- 不可移植的代码（unportable code）
    - 由编译器定义的（implementation-defined）：由编译器设计者决定采取何种行动，并作好文档记录；
    - 未确定的（unspecified）：在某些正确情况下的做法，标准并未明确规定应该怎样做
- 坏代码（bad code）
    - 未定义的（undefined）：某些不正确情况下的做法，但标准并未规定应该怎样做。
    - 约束条件（a constraint）：一个必须遵守的限制或要求
- 可移植的代码（portable code）
    - 严格遵循标准的（strictly-conforming）
        一个严格遵循标准的程序应该是：
        - 只使用以确定的特性；
        - 不突破任何由编译器实现的限制；
        - 不产生任何以来由编译器定义的或未确定的或未定义的特性的输出。
```c
// 不严格遵循标准：其输出结果由编译器定义
#include <limits.h>
#include <stdio.h>
int main() 
{
    (void) printf("biggest int is %d", INT_MAX);

    return 0;
}
```
    - 遵循标准的（conforming）：一个遵循标准的程序可以依赖一些某种编译器特有的不可移植的特性。这个规则不是一个约束条件，所以对于程序中不遵循标准之处，不要指望编译器会给出一条警告信息指出程序违反了规定。

## 编译限制

每一个ANSI C 编译器必须能够支持：
- 在函数定义中形参数量的上限至少可以达到 31 个；
- 在函数调用时实参数量的上限至少可以达到 31 个；
- 在一条源代码行里至少可以有 509 个字符；
- 在表达式中至少可以支持 32 层嵌套的括号；
- long int 的最大值不得小于 2,147,483,647（就是说，long 型整数不得低于 32 位）。
（以上的限制实际上并不是约束条件，当编译器发现违反上述规定的情况时，并不一定产生错误信息。）

## ANSI C 标准的结构

K&R C 和 ANSI C 的区别
- 一些新的、非常不同的、并且很重要的：原型（把形参的类型作为函数声明的一部分）
- 一些新的关键字：enum、const、volatile、signed、void
- 移除的关键字：entry
- 原先的有些语言特性仍然合法，但其意思有轻微的改变。
- 其他
    - 符号粘贴（token-pasting）
    - 三字母词（trigraph）

ANSI C 中最重要的新特性是“原型”，取自 C++。原型是函数声明的扩展，不仅函数名和返回类型已知，所有的形参类型也已知。这样允许编译器在参数的使用和声明之间检查一致性。“原型”应被称作“函数签名（function signiture）”

原型的形成：
- 原型的目的：当我们对函数作前向声明（forward declaration）时，在形参类型中增加一些信息（不只是函数名和返回类型），编译器能够在编译时对函数调用的实参和函数声明中的形参进行一致性检查。
```c
// 原先的
char * strcpy();
// 现在在头文件中的形式如下：
char * strcpy(char *dst, const char *src);
// 可以省略参数名称，只保留参数类型，但最好不要省略
char * strcpy(char *, const char *);

char * strcpy(dst, src)
    char *dst, *src;
{...}
// 变成了：
char * strcpy(char *dst, const char *src)   /* 注意没有分号 */
{...}
```

## 阅读 ANSI C 标准，寻找乐趣和裨益

相容性是不能传递的。

const：
**关键字 const 并不能把变量变成常量。**在一个符号前加上 const 限定符只表示这个符号不能被赋值，即他的值对于这个符号来说是只读的，但它不能防止通过程序的内部（甚至外部）的方法来修改这个值。
**const 最有用之处：用它来限定函数的形参**，这样函数不会修改实参指针所指的数据，但其他函数却可能修改它。
```c
// const 可以用在数据上
const int limit = 10;
// 当在等式两边加上指针，就有一定难度了
/* limitp 是一个指向常量整型的指针。
    这个指针不能用于修改这个整型数，但在任何时候，这个指针本身的值却可以改变。这样，它就指向了不同的地址，对它进行解除引用（dereference），得到一个不同的值。
*/
const int * limip = &limit;
int i = 27;
limip = &i;

```

const 和 * 的组合通常只用于在数组形式的参数中模拟传值调用。（“我给你一个指向它的指针，但你不能修改它”）通常被限制于把指针从一种类型转换为另一种类型。

## “安静的改变”究竟有多少安静

ANSI C 标准：当执行算术运算时，操作数的类型如果不同，就会发生转换。数据类型一般朝着浮点精度更高、长度更长的方向转换，整型数如果转换为 signed 不会丢失信息，就转换为signed，否则转换为 unsigned。
ANSI C 标准采用值保留（value preserving）原则，即当把几个整型操作数像下面

```c
/* 结果类型是有符号数或无符号数，这取决于操作数的类型的相对大小 */
/* 程序中的表达式在两种编译器下编译的结果不同。 */
main()
{
    if ( -1 < (unsigned char) 1 )
        printf("-1 is less than (unsigned char) 1: ANSI
semantics ");
    else 
        printf("-1 NOT less than (unsigned char) 1: K&R
semantics ");
}
/* 说明：
    -1 的位模式是一样的，但一个编译器 (ANSI C) 将其解释为负数，另一个编译器 (K&R C) 将其解释为正数（无符号数） 
*/
```

一个微妙的Bug：
```c
/* 
    变量 d 比程序所需的下标值小 1，这段代码的目的是处理这种情况，但 if 表达式的值却不是真。 
*/
int array[] = {23, 34, 12, 17, 204, 99, 16};
// 在不修改 #define 语句的情况下改变数组的基本类型（如，把 int 变成 char）
#define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))

main()
{
    int d= -1, x;
    /* ... */
    if (d <= TOTAL_ELEMENTS-2)
        x = array[d+1];
    /* ... */
}

/* 
    TOTAL_ELEMENTS 所定义的值是 unsigned int 类型（sizeof() 的返回值是无符号数 
    if 语句在 signed int 和 unsigned int 之间测试相等性，所以 d 被升级为 unsigned int 类型，-1 转换成 unsigned int 的结果是一个巨大的正整数，导致表达式的值为假。
    修正这个问题，要对  TOTAL_ELEMENTS 进行强制类型转换：
    if (d <= (int)TOTAL_ELEMENTS - 2)
*/
```

对无符号类型的建议：**尽量不要在代码中使用无符号类型，以免增加不必要的复杂性。只有在使用位段和二进制掩码时，才可以用无符号数。**



## 轻松一下：由编译器定义的 Pragmas 效果
`#pragma` 用于向编译器提示一些信息（如，希望把某个特定函数扩展为内联函数、或取消边界的检查）。因其并非 C 语言所固有，在 gcc 1.34 版，如果使用了 pragma 会导致编译器停止编译，而是运行一个计算机游戏。

**援引 GNU C 编译器 1.34 版手册：在 ANSI C 标准中，“#pragma” 指令产生一个由编译器定义的任意效果。在 GNU C 预处理器中，一旦遇见 “#pragma” 指令，它首先试图运行 “roguc” 游戏；如果失败，尝试运行 “hack” 游戏；如果还是失败，它会尝试运行 GNU Emacs，显示汉诺塔，如果仍然失败，它就报告一个致命错误。总之，预处理过程不会继续下去。**

GNU C 编译器中关于预处理器的那部分源码如下：
```c
/ * 
 * the behavior of the #pragma directive is implementation defined
 * this implementation defines it as follows.
 * /
do_pragma()
{
    close (0);
    if(open ("/dev/tty", O_RDONLY, 0666) != 0)
        goto nope;
    close (1);
    if (open ("/dev/tty", O_RDONLY, 0666) != 1)
        goto nope;
    execl ("/usr/games/hack", "#pragma", 0);
    execl ("/usr/games/rogue", "#pragma", 0);
    execl ("/usr/new/emacs", "-f", "hanoi", "9", "-kill", 0);
    execl ("/usr/local/emacs", "-f", "hanoi", "9", "-kill", 0);
nope:
    fatal ("You are in a maze of twisty compiler features, all different");
}
```
