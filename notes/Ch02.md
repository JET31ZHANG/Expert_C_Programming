# 这不是 Bug，而是语言特性

## 这关语言特性何事，在Fortran里这就是 Bug 呀

无论什么时候，如果遇见了这样一条语句 `malloc(strlen(str))`，几乎可以断定它是错误的，而 `malloc(strlen(str) + 1)` 才是正确的。因为其他的字符串处理库函数几乎都包含一个额外空间，用于容纳字符串结尾的 `'\0'` 字符。（这个 malloc 错误是库函数的问题）

分析编程语言缺陷的一种方法是把所有缺陷归于 3 类：多做之过、少做之过、误做之过。

一个 'L' 的 NUL 和两个 'L' 的 NULL
    - 一个 'L' 的 NUL：结束一个ASCII 字符串；
    - 两个 'L' 的 NULL：表示什么也不指向（空指针）。

## 多做之过

语言中存在某些不应该存在的特性。它包括易出错的 switch 语句、相邻字符串常量的自动连接和缺省全局范围。

1. 由于存在fall through，switch 语句会带来麻烦

2. 粉笔也成了可用的硬件

3. 太多的缺省可见性



## 误做之过

1. 骆驼背上的重载

2. “有些运算符的优先级是错误的”

3. 早期 gets() 中的 Bug 导致了 Internet 蠕虫

## 少做之过

1. 用户名中若有字母 f，便不能收到邮件

```c
if ( argv[argc - 1][0] == '-' || (argv[argc - 2][1] == 'f') )
    readmail(argc, argv);
else 
    sendmail(argc, argv);
```

2. 空格：最后的领域

3. C++ 的另一种注释形式

```c
int hashval = 0;
/* PJW hash function from "Compilers: Principles, Techniques, and Tools"
 * by Aho, Sethi, and Ullman, Second Edition.
 */
while (cp < bound)
{
    unsigned long overflow;
    hashval = ( hashval << 4 ) + *cp++;
    if ((overflow = hashval & (((unsigned long) 0xF) << 28)) != 0)
        hashval ^= overflow | (overflow >> 24);
}
hashval %= ST_HASHSIZE;         /* 选择起始桶 */
/* 搜索每个表，这次搜索名字，如果失败，保存该字符串。
 * 进入字符串的指针，然后返回它。
 */
for (hp = &st_ihash; ; hp = hp->st_hnext)
{
    int probeval = hashval;     /* 下一个探测值 */
}
```

4. 编译器日期被破坏

```c
/* 将原文件的 timestamp 转换为表示当地格式日期的字符串 */
char *localized_time(char *filename)
{
    struct tm *tm_ptr;
    struct stat stat_block;
    char buffer[120];

    /* 获得源文件的 timestamp，格式为 time_t */
    stat(filename, &stat_block);
    /* 把 UNIX 的 time_t 转换为 tm 结构，里面保存当地时间 */
    tm_ptr = localtime(&stat_block.st_mtime);
    /* 把 tm 结构转换成以当地日期格式表示的字符串 */
    strftime(buffer, sizeof(buffer), "%a %b %e %T %Y", tm_ptr);

    return buffer;
}
```
- 返回一个指向字符串常量的指针

```c
char * func() {
    return "Only works for simple strings";
}
```

- 使用全局声明的数组

```c
char * func() {
    ...
    my_global_array[i] = 
    ...
    return my_global_array;
}
```
- 使用静态数组
```c
char * func() {
    static char buffer[20];
    ...
    return buffer;
}
```

- 显式分配一些内存，保存返回的值

```c
char *func() {
    char *s = malloc( 120 );
    ...
    return s;
}
```
- 也许最好的解决方案就是要求调用者分配内存来保存函数的返回值。为了提高安全性，调用者应该同时指定缓冲区的大小。
```c
void func(char *result, int size)
{
    ...  
    strncpy(result, "That'd be in the data segment, Bob", size);
}

buffer = malloc (size);
func( buffer, size );
...
free(buffer);
```

5. lint 程序绝不应该被分离出来

## 轻松一下：有些特性确实就是Bug

## 参考文献